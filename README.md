# Multi-threaded-Task-Scheduler-Project
## Application's Overview
The Multi-threaded Task Scheduler application is designed to efficiently manage and execute multiple tasks concurrently within an embedded Linux environment. 

This application leverages the power of multi-threading to balance loads and improve performance, crucial for systems requiring high responsiveness and timely processing.


## Core components
### 1. Producers :
These are threads responsible for generating tasks. Each producer might create tasks based on different criteria or triggers, such as time intervals, external events, or system states.

### 2. Consumers :
 Consumer threads pull tasks from the queue and execute them. The number of consumer threads can be adjusted based on the workload and system resources, allowing for dynamic scaling.

### 3. Task Queue :
 This is a central, thread-safe queue that holds tasks generated by the producers. It is designed to handle concurrent access from multiple producers and consumers, ensuring data integrity and synchronization.

### 4. Decorators :
 Utilized within the design pattern context, decorators dynamically add additional behaviors to tasks without modifying their base implementation. Common behaviors include logging, performance tracking, and error handling.

 ## Main Objectives:
1. Efficiency and Responsiveness: By distributing tasks across multiple threads, the system can handle more operations concurrently, reducing idle time and improving overall efficiency.

2. Scalability: The application can scale up or down by adjusting the number of consumer threads based on the current load and system performance metrics. This flexibility is crucial for maintaining optimal performance in systems with varying workloads.

3. Modularity: The use of decorators enhances task modularity, allowing for easy integration of new behaviors as requirements evolve. This feature is particularly beneficial in systems where tasks may require different levels of logging or performance monitoring.

4. Reliability: The thread-safe design of the task queue ensures that tasks are handled reliably, with minimal risk of data races or corruption. Robust error handling and the ability to dynamically add behaviors like retry logic or failure recovery make the system more resilient.

5. Maintainability: The clear separation of concerns and the use of design patterns make the application easier to maintain and extend. Changes in one component, such as how tasks are generated or handled, can be implemented with minimal impact on others.


![Overview](csumer_prduecer.svg)
* the Producer-Consumer pattern is a key concept in software development that helps manage multiple tasks happening at the same time.

* Queue: is a shared space where producer and consumer can exchange information

